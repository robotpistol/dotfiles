const alertStyle = {
  fillColor: {hex: "#282828"}
  strokeColor: {alpha: 0}
  radius: 10
  textSize: 100
  textColor: {hex: "#d65d0e"}
}
import tprint from 'logging'

tprint "Hyper"
export class Hyper
  @mods: {"cmd","alt","shift","ctrl"}
  @spec: (key) => @mods, key
  @key: (key) => -> hs.eventtap.keyStroke(@spec key)
  new: (config = {}) =>
    @inHyperspace = false
    @config = config

  handle: (action) =>
    switch type(action)
      when 'function'
        result, err = pcall -> action(self)
        unless result
          hs.logger.new("hyper").e(err)
          hs.reload!
      when 'table'
        action\handle!
      when 'nil'
        if @inHyperspace
          @modal\exit!
        else
          @modal\enter!
      else tprint "unknown action: #{hs.inspect(action)}"

  initModal: =>
    @modal = with hs.hotkey.modal.new!
      .entered = ->
        screen =(hs.window.focusedWindow! ?? hs.window.frontmostWindow!)\screen!
        @alert = hs.alert.show(@config.name, alertStyle, screen, 'always') if @config.name
        @inHyperspace = true
        hs.timer.delayed.new(3, () -> @modal\exit!).start!
      .exited = ->
        hs.alert.closeSpecific(@alert)
        @inHyperspace = false


  space: (mappings) =>
    bind = if @config.name -- Sub-space, bind to modal instead
      @initModal!
      (key, fn) -> @modal\bind(nil, key, fn)
    else -- top-level, bind directly
      (key, fn) -> hs.hotkey.bind(@@mods, key, fn)
    for key, action in pairs mappings
      bind key, ->
        @handle(action)
        @config.afterAction(self) if @config.afterAction
    self
